@page "/Study/Study"
@model TNS_EDU_STUDY.Areas.Study.Pages.StudyModel
@{
    ViewData["Title"] = $"Luyện tập TOEIC Part {Model.SelectedPart}";
    Layout = "";
}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>@ViewData["Title"]</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />


    <link rel="stylesheet" href="/css/Test.css" />


</head>
<body>
    @* Cấu trúc Header, Main Content, Sidebar Right gần như giữ nguyên từ Test.cshtml *@
    <div class="header">
        <button class="hamburger-btn" onclick="toggleSidebar()">☰</button>
        <button class="exit-btn" onclick="exitTest()">Exit</button>
        <div class="timer" id="timer">Time: 00:00</div>
        <button class="submit-btn" onclick="submitStudy()">Submit</button>
    </div>

    <div class="sidebar-left">
        @* Yêu cầu 2: Chỉ hiển thị một nút cho Part đang làm *@
        <button class="part-btn active" data-part="@Model.SelectedPart">
            <div class="part-btn-icon">
                @* Dùng if-else để hiển thị icon tương ứng *@
                @if (Model.SelectedPart == 1)
                {
                    <i class="fas fa-camera"></i>
                    ;
                }
                else if (Model.SelectedPart == 2)
                {

                    <i class="fas fa-question-circle"></i>
                    ;
                }
                else if (Model.SelectedPart == 3)
                {

                    <i class="fas fa-comments"></i>
                    ;
                }
                else if (Model.SelectedPart == 4)
                {

                    <i class="fas fa-bullhorn"></i>
                    ;
                }
                else if (Model.SelectedPart == 5)
                {

                    <i class="fas fa-edit"></i>
                    ;
                }
                else if (Model.SelectedPart == 6)
                {

                    <i class="fas fa-file-alt"></i>
                    ;
                }
                else if (Model.SelectedPart == 7)
                {

                    <i class="fas fa-newspaper"></i>
                    ;
                }
            </div>
            Part @Model.SelectedPart
        </button>
    </div>

    <div class="main-content">
        <div class="main-content-wrapper" id="main-content-wrapper">
        </div>
    </div>

    <div class="sidebar-right">
        <div id="answered-count" class="answered-count"></div>
        <h3>Questions</h3>
        <div class="part-section" id="question-list"></div>
    </div>

    @* Modal xác nhận, giữ nguyên *@
    <div class="confirmation-modal" id="confirmation-modal">
        <div class="modal-content">
            <h3 id="modal-title">Confirm Action</h3>
            <p id="modal-message">Are you sure?</p>
            <div class="modal-buttons">
                <button class="modal-btn confirm-btn" id="modal-confirm">Confirm</button>
                <button class="modal-btn cancel-btn" id="modal-cancel">Cancel</button>
            </div>
        </div>
    </div>
    <div id="confirm-submit-modal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">Submit Study Session</h2>
            <p class="modal-text">Are you sure you want to finish and submit this study session?</p>
            <div class="modal-buttons">
                <button id="cancel-submit-btn" class="modal-btn cancel-btn">Cancel</button>
                <button id="confirm-submit-btn" class="modal-btn confirm-btn">Confirm</button>
            </div>
        </div>
    </div>
    <script>
        /*
        =================================================================================
        1. KHAI BÁO BIẾN TOÀN CỤC VÀ HẰNG SỐ
        =================================================================================
        */
        let timerInterval;
        let updateTimeInterval;

        // Lấy dữ liệu trực tiếp từ Razor Model (không dùng chuỗi)
        const questions = @Html.Raw(Model.QuestionsJson);
        const resultKey = '@Model.ResultKey';
        const testKey = '@Model.TestKey';
        const currentPart = @Model.SelectedPart;
        let timeRemaining = @Model.TimeRemaining.TotalSeconds;
        const resourceBaseUrl = 'https://localhost:7078';

        let flaggedQuestions = new Set();
        let questionStates = {};
        let debounceTimers = {};
        let sidebarState = 0;

        /*
        =================================================================================
        2. ĐỊNH NGHĨA TẤT CẢ CÁC HÀM
        =================================================================================
        */

        // Xử lý beforeunload để hiển thị hộp thoại xác nhận
        const handleBeforeUnload = (event) => {
            event.preventDefault();
            event.returnValue = '';
        };

                    // Dán hàm này vào vị trí của hàm debounce cũ
        function debouncedSaveAnswer(questionKey, answerKey, timeSpent, part) {
            // Nếu đã có một lần hẹn giờ cho câu hỏi này, hãy hủy nó đi
            if (debounceTimers[questionKey]) {
                clearTimeout(debounceTimers[questionKey]);
            }

            // Tạo một lần hẹn giờ mới CHỈ cho câu hỏi này
            debounceTimers[questionKey] = setTimeout(() => {
                saveAnswer(questionKey, answerKey, timeSpent, part);
            }, 1000); // Vẫn delay 1 giây
        }
     
        function initializeQuestionState(questionKey, part) {
            if (!questionStates[questionKey]) {
                questionStates[questionKey] = {
                    isVisible: false,
                    startTime: null,
                    lastVisibleTime: null, // <-- Đổi tên từ lastAnswerTime
                    timeSpent: 0,
                    answerChanges: 0,
                    part: part
                };
            }
        }


                 // Áp dụng cho cả Study.cshtml và Test.cshtml
        function setupIntersectionObserver() {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const questionKey = entry.target.getAttribute('data-question-key');
                    if (!questionKey || !questionStates[questionKey]) return;

                    const state = questionStates[questionKey];

                    if (entry.isIntersecting) {
                        // KHI CÂU HỎI HIỆN RA: chỉ ghi lại thời điểm nó bắt đầu được nhìn thấy.
                        state.lastVisibleTime = Date.now();
                    } else {
                        // KHI CÂU HỎI BIẾN MẤT: tính toán thời gian đã nhìn thấy và cộng dồn.
                        if (state.lastVisibleTime) {
                            const timeDiff = (Date.now() - state.lastVisibleTime) / 1000;
                            state.timeSpent += timeDiff;
                            state.lastVisibleTime = null; // Reset lại để lần sau tính tiếp
                        }
                    }
                });
            }, { threshold: 0.5 });

            document.querySelectorAll('.question-container, .sub-question').forEach(element => {
                const questionKey = element.getAttribute('data-question-key');
                if (questionKey) observer.observe(element);
            });
        }

        // ======= Giao tiếp server: lưu đáp án, flagged, update time =======
          async function saveAnswer(questionKey, answerKey, timeSpent, part) {
            try {
                const response = await fetch('/Study/Study?handler=SaveAnswer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        resultKey: resultKey,
                        questionKey: questionKey,
                        selectAnswerKey: answerKey,
                        timeSpent: timeSpent,
                        part: part
                    })
                });
                const data = await response.json();
                if (!response.ok || !data.success) {
                    console.error('Error saving answer for question ' + questionKey + ':', data.message || 'Unknown error');
                }
            } catch (error) {
                console.error('Error saving answer for question ' + questionKey + ':', error);
            }
        }
       

        async function loadFlaggedQuestions() {
            try {
                      // THAY ĐỔI DÒNG NÀY
        const response = await fetch(`/Study/Study?handler=FlaggedQuestions&resultKey=${resultKey}`);
                const data = await response.json();
                if (response.ok && Array.isArray(data)) {
                    flaggedQuestions = new Set(data);
                    updateQuestionList();
                } else {
                    console.error('Error loading flagged questions:', data.message || 'Unknown error');
                }
            } catch (error) {
                console.error('Error loading flagged questions:', error);
            }
        }

        async function saveFlaggedQuestion(questionKey, isFlagged) {
            try {
                       // THAY ĐỔI DÒNG NÀY
        const response = await fetch('/Study/Study?handler=SaveFlaggedQuestion', {
       
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        resultKey: resultKey,
                        questionKey: questionKey,
                        isFlagged: isFlagged
                    })
                });
                const data = await response.json();
                if (!response.ok || !data.success) {
                    console.error('Error saving flagged question:', data.message || 'Unknown error');
                }
            } catch (error) {
                console.error('Error saving flagged question:', error);
            }
        }

        // Toggle flagged
        async function toggleFlag(questionKey) {
            const flagElement = document.querySelector(`.flag-icon[data-question-key="${questionKey}"]`);
            const isFlagged = flaggedQuestions.has(questionKey);

            if (isFlagged) {
                flaggedQuestions.delete(questionKey);
                if (flagElement) flagElement.classList.remove('flagged');
                await saveFlaggedQuestion(questionKey, false);
            } else {
                flaggedQuestions.add(questionKey);
                if (flagElement) flagElement.classList.add('flagged');
                await saveFlaggedQuestion(questionKey, true);
            }
            updateQuestionList();
        }

        // ======= Cập nhật UI danh sách câu hỏi (sidebar) =======
        function updateQuestionList() {
            const listContainer = document.getElementById('question-list');
            const answeredContainer = document.getElementById('answered-count');
            if (!listContainer || !answeredContainer) return;

            let html = '';
            let displayedQuestions = [];

            if (currentPart <= 2 || currentPart === 5) {
                displayedQuestions = questions.filter(q => q.parent === null);
            } else {
                const parentQuestions = questions.filter(q => q.parent === null);
                displayedQuestions = parentQuestions.flatMap(p => p.children || []);
            }

            const answeredCount = displayedQuestions.filter(q => q.userAnswerKey && q.userAnswerKey !== '').length;
            const totalCount = displayedQuestions.length;
            answeredContainer.innerHTML = `Answered: ${answeredCount}/${totalCount}`;

            displayedQuestions.forEach(q => {
                const isSelected = q.userAnswerKey && q.userAnswerKey !== '';
                const isFlagged = flaggedQuestions.has(q.questionKey);
                html += `<a href="#" class="question-circle ${isSelected ? 'selected' : ''} ${isFlagged ? 'flagged' : ''}" data-key="${q.questionKey}" onclick="scrollToQuestion('${q.questionKey}')">${q.order}</a>`;
            });

            listContainer.innerHTML = html;
        }

        // ======= Chọn/Bỏ chọn đáp án =======
        function updateAnswer(questionKey, answerKey) {
            let question = questions.find(q => q.questionKey === questionKey);
            if (!question) {
                for (const parent of questions) {
                    if (parent.children) {
                        question = parent.children.find(child => child.questionKey === questionKey);
                        if (question) break;
                    }
                }
            }

            if (question) {
                question.userAnswerKey = answerKey; // có thể là null
                const answerOptions = document.querySelectorAll(`.answer-option input[name="answer_${questionKey}"]`);
                answerOptions.forEach(option => {
                    const parent = option.parentElement;
                    if (answerKey === null) {
                        option.checked = false;
                        parent.classList.remove('selected');
                    } else if (option.value === answerKey) {
                        parent.classList.add('selected');
                    } else {
                        parent.classList.remove('selected');
                    }
                });
                updateQuestionList();
                updateProgressCircle();
            } else {
                console.error(`Question with key ${questionKey} not found.`);
            }
        }

        function selectAnswer(questionKey, answerKey) {
            let question = questions.find(q => q.questionKey === questionKey);
            if (!question) {
                for (const parent of questions) {
                    if (parent.children) {
                        question = parent.children.find(child => child.questionKey === questionKey);
                        if (question) break;
                    }
                }
            }
            if (!question) return;

            const radioButton = document.querySelector(`input[name="answer_${questionKey}"][value="${answerKey}"]`);
            if (!radioButton) return;

            const isAlreadySelected = question.userAnswerKey === answerKey;
            const state = questionStates[questionKey];
            const currentTime = Date.now();

            // **LOGIC TÍNH TOÁN MỚI**
            // 1. Tính toán và cộng nốt phần thời gian từ lúc câu hỏi hiện ra cho tới lúc click.
            if (state.lastVisibleTime) {
                const timeDiff = (currentTime - state.lastVisibleTime) / 1000;
                state.timeSpent += timeDiff;
            }

            // 2. Cập nhật lại thời điểm cuối cùng, chuẩn bị cho lần tính toán tiếp theo.
            state.lastVisibleTime = currentTime;
            state.answerChanges += 1;

            // Phần logic còn lại giữ nguyên
            if (isAlreadySelected) { // Bỏ chọn
                radioButton.checked = false;
                updateAnswer(questionKey, null);
                debouncedSaveAnswer(questionKey, null, Math.round(state.timeSpent), state.part);
            } else { // Chọn mới
                radioButton.checked = true;
                updateAnswer(questionKey, answerKey);
                debouncedSaveAnswer(questionKey, answerKey, Math.round(state.timeSpent), state.part);
            }
        }
        // ======= Render ==========================
        function renderSimplePart(container) {
            const partQuestions = questions.filter(q => Number(q.part) === currentPart && q.parent === null);
            let html = '';
            partQuestions.forEach(question => {
                initializeQuestionState(question.questionKey, question.part);
                const isFlagged = flaggedQuestions.has(question.questionKey);
                html += `
                    <div class="question-container" id="question-${question.questionKey}" data-question-key="${question.questionKey}">
                        <h2>Question ${question.order}</h2>
                        <span class="flag-icon ${isFlagged ? 'flagged' : ''}" data-question-key="${question.questionKey}"><i class="fas fa-flag"></i></span>
                        ${question.questionImage ? `<img src="${resourceBaseUrl}${question.questionImage}" alt="Question Image" class="question-image" loading="lazy">` : ''}
                        ${question.questionVoice ? `
                            <audio controls class="question-audio">
                                <source src="${resourceBaseUrl}${question.questionVoice}" type="audio/mpeg">
                                Your browser does not support the audio element.
                            </audio>` : ''}
                        ${question.questionText ? `<div class="question-text">${question.questionText}</div>` : ''}
                        <div class="answer-options">
                `;
                question.answers.forEach((answer, idx) => {
                    const label = (currentPart === 1 || currentPart === 2)
                        ? (answer.ranking === 1 ? 'A' : answer.ranking === 2 ? 'B' : answer.ranking === 3 ? 'C' : answer.ranking === 4 ? 'D' : '?')
                        : String.fromCharCode(65 + idx);
                    const isChecked = answer.answerKey === question.userAnswerKey ? 'checked' : '';
                    const isSelected = answer.answerKey === question.userAnswerKey ? 'selected' : '';
                    html += `
                        <div class="answer-option ${isSelected}" onclick="selectAnswer('${question.questionKey}', '${answer.answerKey}')">
                            <input type="radio" name="answer_${question.questionKey}" id="answer_${answer.answerKey}"
                                   value="${answer.answerKey}" ${isChecked}>
                            <label for="answer_${answer.answerKey}">
                                <span class="label-text">${label}</span>
                                ${currentPart === 1 || currentPart === 2 ? '' : `<span class="colon">:</span> <span class="answer-content">${answer.answerText}</span>`}
                            </label>
                        </div>
                    `;
                });
                html += '</div></div>';
            });
            container.innerHTML = html;

           

            document.querySelectorAll('.flag-icon').forEach(flag => {
                flag.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const questionKey = flag.getAttribute('data-question-key');
                    toggleFlag(questionKey);
                });
            });

            setupIntersectionObserver();
        }

        function renderComplexPart(container) {
            const parentQuestions = questions.filter(q => Number(q.part) === currentPart && q.parent === null);
            let html = '';

            if (parentQuestions.length === 0) {
                container.innerHTML = `<p>No questions available for Part ${currentPart}.</p>`;
                return;
            }

            parentQuestions.forEach(parent => {
                html += `
                    <div class="part3-container">
                        <div class="part3-left">
                            <h2>Part ${currentPart}: Conversation</h2>
                            ${parent.questionImage ? `<img src="${resourceBaseUrl}${parent.questionImage}" alt="Part ${currentPart} Image" class="question-image" loading="lazy">` : ''}
                            ${parent.questionVoice ? `
                                <audio controls class="question-audio">
                                    <source src="${resourceBaseUrl}${parent.questionVoice}" type="audio/mpeg">
                                    Your browser does not support the audio element.
                                </audio>` : ''}
                            ${parent.questionText ? `<div class="question-text">${parent.questionText}</div>` : ''}
                        </div>
                        <div class="part3-right">
                `;
                const children = parent.children || [];
                children.forEach(child => {
                    initializeQuestionState(child.questionKey, child.part);
                    const isFlagged = flaggedQuestions.has(child.questionKey);
                    html += `
                        <div class="sub-question" id="question-${child.questionKey}" data-question-key="${child.questionKey}">
                            <h4>Question ${child.order}${child.questionText ? `<span class="question-content">: ${child.questionText}</span>` : ''}</h4>
                            <span class="flag-icon ${isFlagged ? 'flagged' : ''}" data-question-key="${child.questionKey}"><i class="fas fa-flag"></i></span>
                            ${child.questionImage ? `<img src="${resourceBaseUrl}${child.questionImage}" alt="Sub Question Image" class="sub-question-image" loading="lazy">` : ''}
                            ${child.questionVoice ? `
                                <audio controls class="sub-question-audio">
                                    <source src="${resourceBaseUrl}${child.questionVoice}" type="audio/mpeg">
                                    Your browser does not support the audio element.
                                </audio>` : ''}
                            <div class="answer-options">
                    `;
                    child.answers.forEach((answer, idx) => {
                        const label = String.fromCharCode(65 + idx);
                        const isChecked = answer.answerKey === child.userAnswerKey ? 'checked' : '';
                        const isSelected = answer.answerKey === child.userAnswerKey ? 'selected' : '';
                        html += `
                            <div class="answer-option ${isSelected}" onclick="selectAnswer('${child.questionKey}', '${answer.answerKey}')">
                                <input type="radio" name="answer_${child.questionKey}" id="answer_${answer.answerKey}"
                                       value="${answer.answerKey}" ${isChecked}>
                                <label for="answer_${answer.answerKey}">
                                    <span class="label-text">${label}</span>
                                    <span class="colon">:</span>
                                    <span class="answer-content">${answer.answerText}</span>
                                </label>
                            </div>
                        `;
                    });
                    html += '</div></div>';
                });
                html += '</div></div>';
            });

            container.innerHTML = html;

          

            document.querySelectorAll('.flag-icon').forEach(flag => {
                flag.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const questionKey = flag.getAttribute('data-question-key');
                    toggleFlag(questionKey);
                });
            });

            setupIntersectionObserver();
        }

        // Scroll tới câu hỏi
        function scrollToQuestion(questionKey) {
            const element = document.getElementById(`question-${questionKey}`);
            if (element) element.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // Modal xác nhận (dùng chung)
        function showConfirmationModal(title, message, onConfirm) {
            const modal = document.getElementById('confirmation-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalMessage = document.getElementById('modal-message');
            const confirmBtn = document.getElementById('modal-confirm');
            const cancelBtn = document.getElementById('modal-cancel');

            if (!modal) {
                // fallback: confirm browser
                if (confirm(message)) {
                    if (onConfirm) onConfirm();
                }
                return;
            }

            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modal.classList.add('active');

            confirmBtn.onclick = () => {
                modal.classList.remove('active');
                if (onConfirm) onConfirm();
            };

            cancelBtn.onclick = () => {
                modal.classList.remove('active');
            };
        }

        // Exit test (quay về trang Study)
        function exitTest() {
            showConfirmationModal(
                'Exit Study Session',
                'Are you sure you want to exit? Your progress will be saved.',
                () => {
                    window.removeEventListener('beforeunload', handleBeforeUnload);
                    window.location.href = '/Study';
                }
            );
        }

        // ======= Submit study (tự động hoặc thủ công) =======
        async function submitStudy() {
            const confirmModal = document.getElementById('confirm-submit-modal');
            const confirmBtn = document.getElementById('confirm-submit-btn');
            const cancelBtn = document.getElementById('cancel-submit-btn');

            // nếu không có modal, fallback dùng confirm
            if (!confirmModal) {
                if (!confirm('Submit study session?')) return;
            } else {
                confirmModal.style.display = 'block';
                const userConfirmed = await new Promise(resolve => {
                    confirmBtn.onclick = () => { confirmModal.style.display = 'none'; resolve(true); };
                    cancelBtn.onclick = () => { confirmModal.style.display = 'none'; resolve(false); };
                });
                if (!userConfirmed) return;
            }

            // Dừng timer & update interval
            clearInterval(timerInterval);
            clearInterval(updateTimeInterval);

            try {
                const response = await fetch('/Study/Study?handler=SubmitStudy', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        resultKey: resultKey,
                        selectedPart: currentPart
                    })
                });

                if (response.ok) {
                    window.location.href = `/Study/ResultStudy?TestKey=${testKey}&ResultKey=${resultKey}&PartSelect=${currentPart}`;
                } else {
                    console.error('Failed to submit study session.');
                    alert('An error occurred while submitting. Please try again.');
                }
            } catch (error) {
                console.error('Error submitting study session:', error);
                alert('An error occurred. Please check your connection and try again.');
            }
        }

        // ======= Timer: đếm ngược + cập nhật lên server mỗi phút (đã hợp nhất) =======
        function startTimer() {
            const timerElement = document.getElementById('timer');
            if (!timerElement) return;

            // Đồng hồ đếm ngược mỗi giây
            timerInterval = setInterval(() => {
                if (timeRemaining > 0) {
                    timeRemaining--;
                    const minutes = Math.floor(timeRemaining / 60);
                    const seconds = Math.round(timeRemaining % 60);
                    timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    clearInterval(timerInterval);
                    timerElement.textContent = "00:00";
                    // tự động nộp
                    submitStudy();
                }
            }, 1000);

            // Cập nhật thời gian đã làm lên server mỗi 60 giây
            updateTimeInterval = setInterval(() => {
                try {
                    fetch('/Study/Study?handler=UpdateTimeSpent', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ resultKey: resultKey })
                    });
                } catch (error) {
                    console.error('Failed to update time spent:', error);
                }
            }, 60000);
        }

        // ======= Sidebar helper / progress ==========
        function getTotalQuestions() {
            let total = 0;
            questions.forEach(q => {
                if (q.parent === null) {
                    if (q.children && q.children.length > 0) {
                        total += q.children.length;
                    } else {
                        total += 1;
                    }
                }
            });
            return total;
        }

        function getAnsweredQuestions() {
            let answered = 0;
            questions.forEach(q => {
                if (q.parent === null && q.children && q.children.length > 0) {
                    answered += q.children.filter(child => child.userAnswerKey && child.userAnswerKey !== '').length;
                } else if (q.parent === null && q.userAnswerKey && q.userAnswerKey !== '') {
                    answered += 1;
                }
            });
            return answered;
        }

        function updateProgressCircle() {
            const totalQuestions = getTotalQuestions();
            const answeredQuestions = getAnsweredQuestions();
            const text = document.getElementById('progress-text');
            if (text) text.textContent = `${answeredQuestions}/${totalQuestions}`;
        }

        // Reload if page was loaded from BFCache
        window.onpageshow = function (event) {
            if (event.persisted) {
                window.location.reload();
            }
        };

        // Keydown navigation (ArrowUp/ArrowDown)
        document.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                event.preventDefault();
                const questionsOnPage = Array.from(document.querySelectorAll('.question-container, .sub-question'));
                if (questionsOnPage.length < 2) return;

                const viewportCenter = window.innerHeight / 2;
                let currentQuestionOnPage = null;
                let minDistanceToCenter = Infinity;

                questionsOnPage.forEach(q => {
                    const rect = q.getBoundingClientRect();
                    const questionCenter = rect.top + (rect.height / 2);
                    const distance = Math.abs(questionCenter - viewportCenter);
                    if (distance < minDistanceToCenter) {
                        minDistanceToCenter = distance;
                        currentQuestionOnPage = q;
                    }
                });

                if (!currentQuestionOnPage) return;
                const currentIndex = questionsOnPage.indexOf(currentQuestionOnPage);
                if (currentIndex === -1) return;

                let nextIndex = currentIndex;
                if (event.key === 'ArrowUp' && currentIndex > 0) {
                    nextIndex--;
                } else if (event.key === 'ArrowDown' && currentIndex < questionsOnPage.length - 1) {
                    nextIndex++;
                }

                const nextQuestionOnPage = questionsOnPage[nextIndex];
                if (nextQuestionOnPage && nextQuestionOnPage !== currentQuestionOnPage) {
                    nextQuestionOnPage.scrollIntoView({ behavior: 'smooth', block: 'center' });

                    const nextKey = nextQuestionOnPage.getAttribute('data-question-key');
                    if (nextKey) {
                        const questionCircles = Array.from(document.querySelectorAll('.question-circle'));
                        questionCircles.forEach(circle => {
                            if (circle.getAttribute('data-key') === nextKey) {
                                circle.classList.add('active');
                            } else {
                                circle.classList.remove('active');
                            }
                        });
                    }
                }
            }
        });

        /*
        =================================================================================
        3. ĐIỂM KHỞI CHẠY (ENTRY POINT)
        =================================================================================
        */
        window.onload = async function () {
            // Đăng ký beforeunload
            window.addEventListener('beforeunload', handleBeforeUnload);

            // Tải flagged questions từ server (nếu có)
            await loadFlaggedQuestions();

            // Render nội dung
            const container = document.getElementById('main-content-wrapper');
            if (container) {
                if ([1, 2, 5].includes(currentPart)) {
                    renderSimplePart(container);
                } else {
                    renderComplexPart(container);
                }
            }

            // Cập nhật danh sách sidebar
            updateQuestionList();

            // Khởi tạo state cho từng câu hỏi
            questions.forEach(q => {
                initializeQuestionState(q.questionKey, q.part);
                if (q.children) q.children.forEach(child => initializeQuestionState(child.questionKey, child.part));
            });

            // Gắn sự kiện click cho question-list (delegation)
            const qlist = document.getElementById('question-list');
            if (qlist) {
                qlist.addEventListener('click', function(event) {
                    if (event.target.classList.contains('question-circle')) {
                        event.preventDefault();
                        const questionKey = event.target.getAttribute('data-key');
                        if (questionKey) scrollToQuestion(questionKey);
                    }
                });
            }

            // Bắt đầu timer sau khi mọi thứ sẵn sàng
            startTimer();
        };
    </script>

</body>
</html>
<style>
    /* --- Thêm đoạn CSS này vào thẻ <style> --- */

    /* CSS for Confirmation Modal */
    .modal {
        display: none; /* Ẩn mặc định */
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.6);
        animation: fadeIn 0.3s;
    }

    .modal-content {
        background-color: #fff;
        margin: 15% auto;
        padding: 30px;
        border: 1px solid #888;
        width: 80%;
        max-width: 450px;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        animation: slideIn 0.3s;
    }

    .modal-title {
        font-size: 1.5rem;
        font-weight: 600;
        margin-bottom: 15px;
        color: #333;
    }

    .modal-text {
        margin-bottom: 25px;
        color: #555;
        font-size: 1.1rem;
    }

    .modal-buttons {
        display: flex;
        justify-content: center;
        gap: 15px;
    }

    .modal-btn {
        padding: 10px 25px;
        border: none;
        border-radius: 25px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .cancel-btn {
        background-color: #f0f0f0;
        color: #333;
    }

        .cancel-btn:hover {
            background-color: #e0e0e0;
        }

    .confirm-btn {
        background-color: #d32f2f;
        color: white;
    }

        .confirm-btn:hover {
            background-color: #c62828;
            transform: translateY(-2px);
        }

@@keyframes fadeIn {
        from

    {
        opacity: 0;
    }

    to {
        opacity: 1;
    }

    }
@@keyframes slideIn {
        from

    {
        transform: translateY(-50px);
    }

    to {
        transform: translateY(0);
    }

    }

    .sidebar-left {
        justify-content: center;
        align-items: center;
    }

        .sidebar-left .part-btn {
            flex: 0 0 auto; /* Bỏ thuộc tính flex: 1 để nút không bị kéo dài ra */
            width: 80%; /* Chiều rộng của nút */
            height: 100px; /* Chiều cao của nút */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

    .part-btn-icon {
        font-size: 2.5rem;
        margin-bottom: 5px;
    }
</style>