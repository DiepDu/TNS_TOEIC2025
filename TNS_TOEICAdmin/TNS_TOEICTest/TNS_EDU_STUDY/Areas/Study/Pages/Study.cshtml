@page "/Study/Study"
@model TNS_EDU_STUDY.Areas.Study.Pages.StudyModel
@{
    ViewData["Title"] = $"Luyện tập TOEIC Part {Model.SelectedPart}";
    Layout = "";
}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>@ViewData["Title"]</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />


    <link rel="stylesheet" href="/css/Test.css" />

    <style>
       
        .sidebar-left {
            justify-content: center;
            align-items: center;
        }

            .sidebar-left .part-btn {
                flex: 0 0 auto; /* Bỏ thuộc tính flex: 1 để nút không bị kéo dài ra */
                width: 80%; /* Chiều rộng của nút */
                height: 100px; /* Chiều cao của nút */
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
            }

        .part-btn-icon {
            font-size: 2.5rem;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    @* Cấu trúc Header, Main Content, Sidebar Right gần như giữ nguyên từ Test.cshtml *@
    <div class="header">
        <button class="hamburger-btn" onclick="toggleSidebar()">☰</button>
        <button class="exit-btn" onclick="exitTest()">Exit</button>
        <div class="timer" id="timer">Time: 00:00</div>
        <button class="submit-btn" onclick="submitStudy()">Submit</button>
    </div>

    <div class="sidebar-left">
        @* Yêu cầu 2: Chỉ hiển thị một nút cho Part đang làm *@
        <button class="part-btn active" data-part="@Model.SelectedPart">
            <div class="part-btn-icon">
                @* Dùng if-else để hiển thị icon tương ứng *@
                @if (Model.SelectedPart == 1)
                {
                    <i class="fas fa-camera"></i>
                    ;
                }
                else if (Model.SelectedPart == 2)
                {

                    <i class="fas fa-question-circle"></i>
                    ;
                }
                else if (Model.SelectedPart == 3)
                {

                    <i class="fas fa-comments"></i>
                    ;
                }
                else if (Model.SelectedPart == 4)
                {

                    <i class="fas fa-bullhorn"></i>
                    ;
                }
                else if (Model.SelectedPart == 5)
                {

                    <i class="fas fa-edit"></i>
                    ;
                }
                else if (Model.SelectedPart == 6)
                {

                    <i class="fas fa-file-alt"></i>
                    ;
                }
                else if (Model.SelectedPart == 7)
                {

                    <i class="fas fa-newspaper"></i>
                    ;
                }
            </div>
            Part @Model.SelectedPart
        </button>
    </div>

    <div class="main-content">
        <div class="main-content-wrapper" id="main-content-wrapper">
        </div>
    </div>

    <div class="sidebar-right">
        <div id="answered-count" class="answered-count"></div>
        <h3>Questions</h3>
        <div class="part-section" id="question-list"></div>
    </div>

    @* Modal xác nhận, giữ nguyên *@
    <div class="confirmation-modal" id="confirmation-modal">
        <div class="modal-content">
            <h3 id="modal-title">Confirm Action</h3>
            <p id="modal-message">Are you sure?</p>
            <div class="modal-buttons">
                <button class="modal-btn confirm-btn" id="modal-confirm">Confirm</button>
                <button class="modal-btn cancel-btn" id="modal-cancel">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Lấy dữ liệu từ Model
        const rawJson = '@Html.Raw(Model.QuestionsJson)';
        const questions = rawJson ? JSON.parse(rawJson) : [];
        const testKey = '@Model.TestKey';
        const resultKey = '@Model.ResultKey';
        const currentPart = @Model.SelectedPart;
        let timeRemaining = @Model.TimeRemaining.TotalSeconds;
        const resourceBaseUrl = 'https://localhost:7078';

        // Các biến trạng thái khác
        let flaggedQuestions = new Set();
        let questionStates = {};
        let debounceTimers = {};
            const handleBeforeUnload = (event) => {
            // Đây là cách chuẩn để kích hoạt hộp thoại xác nhận của trình duyệt
            event.preventDefault();
            event.returnValue = ''; // Dòng này là bắt buộc cho một số trình duyệt
        };

        // --- LOGIC MỚI: CẬP NHẬT THỜI GIAN ĐÃ LÀM LÊN SERVER ---
        setInterval(async () => {
            try {
                await fetch('/Study/Study?handler=UpdateTimeSpent', { // Gọi đến handler mới
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ resultKey: resultKey })
                });
            } catch (error) {
                console.error('Failed to update time spent:', error);
            }
        }, 60000); // Cập nhật mỗi 60 giây (1 phút)

        // --- CÁC HÀM JAVASCRIPT ĐƯỢC TÁI SỬ DỤNG VÀ ĐƠN GIẢN HÓA TỪ TEST.CSHTML ---

        // Hàm render nội dung, đã được đơn giản hóa
        function renderContent() {
            const container = document.getElementById('main-content-wrapper');
            // Không cần switchPart, chỉ cần render dựa trên currentPart
            if ([1, 2, 5].includes(currentPart)) {
                renderSimplePart(container);
            } else {
                renderComplexPart(container);
            }
            setupIntersectionObserver();
        }

        // Hàm cập nhật danh sách câu hỏi, đã được đơn giản hóa
        function updateQuestionList() {
            const listContainer = document.getElementById('question-list');
            const answeredContainer = document.getElementById('answered-count');
            let html = '';
            let displayedQuestions = [];

            if (currentPart <= 2 || currentPart === 5) {
                displayedQuestions = questions.filter(q => q.parent === null);
            } else {
                   // 1. Dùng .filter để lấy TẤT CẢ các câu hỏi cha
        const parentQuestions = questions.filter(q => q.parent === null);
        // 2. Dùng .flatMap để tạo một danh sách duy nhất chứa TẤT CẢ câu hỏi con từ tất cả các câu cha
        displayedQuestions = parentQuestions.flatMap(p => p.children || []);
            }

            const answeredCount = displayedQuestions.filter(q => q.userAnswerKey && q.userAnswerKey !== '').length;
            const totalCount = displayedQuestions.length;
            answeredContainer.innerHTML = `Answered: ${answeredCount}/${totalCount}`;

            displayedQuestions.forEach(q => {
                const isSelected = q.userAnswerKey && q.userAnswerKey !== '';
                const isFlagged = flaggedQuestions.has(q.questionKey);
                html += `<a href="#" class="question-circle ${isSelected ? 'selected' : ''} ${isFlagged ? 'flagged' : ''}" data-key="${q.questionKey}" onclick="scrollToQuestion('${q.questionKey}')">${q.order}</a>`;
            });
            listContainer.innerHTML = html;
        }

        // Hàm nộp bài, gọi đến handler mới OnPostSubmitStudy
        function submitStudy() {
            showConfirmationModal(
                'Submit Study Session',
                'Are you sure you want to finish and submit this study session?',
                async () => {
                    try {
                        const response = await fetch('/Study/Study?handler=SubmitStudy', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ resultKey: resultKey })
                        });
                        const data = await response.json();
                        if (response.ok && data.success) {
                            window.removeEventListener('beforeunload', handleBeforeUnload);
                            window.location.href = `/Test/ResultTest?resultKey=${resultKey}`;
                        } else {
                            alert('Error submitting session: ' + (data.message || 'Unknown error'));
                        }
                    } catch (error) {
                        console.error('Error submitting session:', error);
                        alert('An error occurred while submitting the session.');
                    }
                }
            );
        }

        function exitTest() {
            showConfirmationModal(
                'Exit Study Session',
                'Are you sure you want to exit? Your progress will be saved.',
                () => {
                    window.removeEventListener('beforeunload', handleBeforeUnload);
                    window.location.href = '/Study'; // Quay về trang chọn Part
                }
            );
        }

       
                  function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // 2. Hàm saveAnswer (định nghĩa riêng)
        async function saveAnswer(questionKey, answerKey, timeSpent, part) {
            try {
                // URL đã được sửa lại cho đúng
                const response = await fetch('/Study/Study?handler=SaveAnswer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        resultKey: resultKey,
                        questionKey: questionKey,
                        selectAnswerKey: answerKey,
                        timeSpent: timeSpent,
                        part: part
                    })
                });
                const data = await response.json();
                if (!response.ok || !data.success) {
                    console.error('Error saving answer:', data.message || 'Unknown error');
                }
            } catch (error) {
                console.error('Error saving answer:', error);
            }
        }

        // 3. Tạo biến debouncedSaveAnswer (đặt ở ngoài, sau khi đã định nghĩa 2 hàm trên)
        const debouncedSaveAnswer = debounce(saveAnswer, 1000);
                function initializeQuestionState(questionKey, part) {
            if (!questionStates[questionKey]) {
                questionStates[questionKey] = {
                    isVisible: false,
                    hasInteracted: false,
                    startTime: null,
                    lastAnswerTime: null,
                    timeSpent: 0,
                    answerChanges: 0,
                    part: part
                };
            }
        }
                function setupIntersectionObserver() {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const questionKey = entry.target.getAttribute('data-question-key');
                    if (!questionStates[questionKey]) return;

                    if (entry.isIntersecting) {
                        questionStates[questionKey].isVisible = true;
                        checkStartTime(questionKey);
                    } else {
                        questionStates[questionKey].isVisible = false;
                    }
                });
            }, {
                threshold: 0.5
            });

            document.querySelectorAll('.question-container, .sub-question').forEach(element => {
                const questionKey = element.getAttribute('data-question-key');
                if (questionKey) {
                    observer.observe(element);
                }
            });
        }
                function checkStartTime(questionKey) {
            const state = questionStates[questionKey];
            if (state.isVisible && state.hasInteracted && !state.startTime) {
                state.startTime = Date.now();
            }
        }
                async function loadFlaggedQuestions() {
            try {
                const response = await fetch(`/MainTest?handler=FlaggedQuestions&resultKey=${resultKey}`);
                const data = await response.json();
                if (response.ok && Array.isArray(data)) {
                    flaggedQuestions = new Set(data);
                    updateQuestionList();
                } else {
                    console.error('Error loading flagged questions:', data.message || 'Unknown error');
                }
            } catch (error) {
                console.error('Error loading flagged questions:', error);
            }
        }
              async function saveFlaggedQuestion(questionKey, isFlagged) {
            try {
                const response = await fetch('/MainTest?handler=SaveFlaggedQuestion', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        resultKey: resultKey,
                        questionKey: questionKey,
                        isFlagged: isFlagged
                    })
                });
                const data = await response.json();
                if (!response.ok || !data.success) {
                    console.error('Error saving flagged question:', data.message || 'Unknown error');
                }
            } catch (error) {
                console.error('Error saving flagged question:', error);
            }
        }

        async function toggleFlag(questionKey) {
            const flagElement = document.querySelector(`.flag-icon[data-question-key="${questionKey}"]`);
            const isFlagged = flaggedQuestions.has(questionKey);

            if (isFlagged) {
                flaggedQuestions.delete(questionKey);
                flagElement.classList.remove('flagged');
                await saveFlaggedQuestion(questionKey, false);
            } else {
                flaggedQuestions.add(questionKey);
                flagElement.classList.add('flagged');
                await saveFlaggedQuestion(questionKey, true);
            }
            updateQuestionList();
        }
              function selectAnswer(questionKey, answerKey) {
            let question = questions.find(q => q.questionKey === questionKey);
            if (!question) {
                for (const parent of questions) {
                    if (parent.children) {
                        question = parent.children.find(child => child.questionKey === questionKey);
                        if (question) break;
                    }
                }
            }

            if (!question) {
                console.error(`Question with key ${questionKey} not found.`);
                return;
            }

            const radioButton = document.querySelector(`input[name="answer_${questionKey}"][value="${answerKey}"]`);
            if (!radioButton) return;

            // Kiểm tra xem đáp án đã được chọn chưa
            const isAlreadySelected = question.userAnswerKey === answerKey;

            if (isAlreadySelected) {
                // Bỏ chọn đáp án
                radioButton.checked = false;
                updateAnswer(questionKey, null); // Đặt userAnswerKey về null

                const state = questionStates[questionKey];
                if (state && state.startTime) {
                    const currentTime = Date.now();
                    let timeDiff;

                    if (state.lastAnswerTime) {
                        timeDiff = (currentTime - state.lastAnswerTime) / 1000;
                        state.answerChanges += 1;
                    } else {
                        timeDiff = (currentTime - state.startTime) / 1000;
                    }

                    state.timeSpent += timeDiff;
                    state.lastAnswerTime = currentTime;

                    // Gửi request với selectAnswerKey = null
                    debouncedSaveAnswer(
                        questionKey,
                        null, // Bỏ chọn
                        Math.round(state.timeSpent),
                        state.part
                    );
                }
            } else {
                // Chọn đáp án mới
                radioButton.checked = true;
                updateAnswer(questionKey, answerKey);

                const state = questionStates[questionKey];
                if (state && state.startTime) {
                    const currentTime = Date.now();
                    let timeDiff;

                    if (state.lastAnswerTime) {
                        timeDiff = (currentTime - state.lastAnswerTime) / 1000;
                        state.answerChanges += 1;
                    } else {
                        timeDiff = (currentTime - state.startTime) / 1000;
                    }

                    state.timeSpent += timeDiff;
                    state.lastAnswerTime = currentTime;

                    debouncedSaveAnswer(
                        questionKey,
                        answerKey,
                        Math.round(state.timeSpent),
                        state.part
                    );
                }
            }
        }

              function renderSimplePart(container) {
            const partQuestions = questions.filter(q => Number(q.part) === currentPart && q.parent === null);
            let html = '';
            partQuestions.forEach(question => {
                initializeQuestionState(question.questionKey, question.part);
                const isFlagged = flaggedQuestions.has(question.questionKey);
                html += `
                    <div class="question-container" id="question-${question.questionKey}" data-question-key="${question.questionKey}">
                        <h2>Question ${question.order}</h2>
                        <span class="flag-icon ${isFlagged ? 'flagged' : ''}" data-question-key="${question.questionKey}"><i class="fas fa-flag"></i></span>
                        ${question.questionImage ? `<img src="${resourceBaseUrl}${question.questionImage}" alt="Question Image" class="question-image" loading="lazy">` : ''}
                        ${question.questionVoice ? `
                            <audio controls class="question-audio">
                                <source src="${resourceBaseUrl}${question.questionVoice}" type="audio/mpeg">
                                Your browser does not support the audio element.
                            </audio>` : ''}
                        ${question.questionText ? `<div class="question-text">${question.questionText}</div>` : ''}
                        <div class="answer-options">
                `;
                question.answers.forEach((answer, idx) => {
                    const label = (currentPart === 1 || currentPart === 2)
                        ? (answer.ranking === 1 ? 'A' : answer.ranking === 2 ? 'B' : answer.ranking === 3 ? 'C' : answer.ranking === 4 ? 'D' : '?')
                        : String.fromCharCode(65 + idx);
                    const isChecked = answer.answerKey === question.userAnswerKey ? 'checked' : '';
                    const isSelected = answer.answerKey === question.userAnswerKey ? 'selected' : '';
                    html += `
                        <div class="answer-option ${isSelected}" onclick="selectAnswer('${question.questionKey}', '${answer.answerKey}')">
                            <input type="radio" name="answer_${question.questionKey}" id="answer_${answer.answerKey}"
                                   value="${answer.answerKey}" ${isChecked}>
                            <label for="answer_${answer.answerKey}">
                                <span class="label-text">${label}</span>
                                ${currentPart === 1 || currentPart === 2 ? '' : `<span class="colon">:</span> <span class="answer-content">${answer.answerText}</span>`}
                            </label>
                        </div>
                    `;
                });
                html += '</div></div>';
            });
            container.innerHTML = html;

            document.querySelectorAll('.question-container, .sub-question').forEach(element => {
                const questionKey = element.getAttribute('data-question-key');
                if (questionKey) {
                    const answerOptions = element.querySelector('.answer-options');
                    if (answerOptions) {
                        answerOptions.addEventListener('mouseover', () => {
                            if (questionStates[questionKey]) {
                                questionStates[questionKey].hasInteracted = true;
                                checkStartTime(questionKey);
                            }
                        });
                    }
                }
            });

            document.querySelectorAll('.flag-icon').forEach(flag => {
                flag.addEventListener('click', () => {
                    const questionKey = flag.getAttribute('data-question-key');
                    toggleFlag(questionKey);
                });
            });

            setupIntersectionObserver();
        }

        function renderComplexPart(container) {
            const parentQuestions = questions.filter(q => Number(q.part) === currentPart && q.parent === null);
            let html = '';

            if (parentQuestions.length === 0) {
                container.innerHTML = `<p>No questions available for Part ${currentPart}.</p>`;
                return;
            }

            parentQuestions.forEach(parent => {
                html += `
                    <div class="part3-container">
                        <div class="part3-left">
                            <h2>Part ${currentPart}: Conversation</h2>
                            ${parent.questionImage ? `<img src="${resourceBaseUrl}${parent.questionImage}" alt="Part ${currentPart} Image" class="question-image" loading="lazy">` : ''}
                            ${parent.questionVoice ? `
                                <audio controls class="question-audio">
                                    <source src="${resourceBaseUrl}${parent.questionVoice}" type="audio/mpeg">
                                    Your browser does not support the audio element.
                                </audio>` : ''}
                            ${parent.questionText ? `<div class="question-text">${parent.questionText}</div>` : ''}
                        </div>
                        <div class="part3-right">
                `;
                const children = parent.children || [];
                children.forEach(child => {
                    initializeQuestionState(child.questionKey, child.part);
                    const isFlagged = flaggedQuestions.has(child.questionKey);
                    html += `
                        <div class="sub-question" id="question-${child.questionKey}" data-question-key="${child.questionKey}">
                            <h4>Question ${child.order}${child.questionText ? `<span class="question-content">: ${child.questionText}</span>` : ''}</h4>
                            <span class="flag-icon ${isFlagged ? 'flagged' : ''}" data-question-key="${child.questionKey}"><i class="fas fa-flag"></i></span>
                            ${child.questionImage ? `<img src="${resourceBaseUrl}${child.questionImage}" alt="Sub Question Image" class="sub-question-image" loading="lazy">` : ''}
                            ${child.questionVoice ? `
                                <audio controls class="sub-question-audio">
                                    <source src="${resourceBaseUrl}${child.questionVoice}" type="audio/mpeg">
                                    Your browser does not support the audio element.
                                </audio>` : ''}
                            <div class="answer-options">
                    `;
                    child.answers.forEach((answer, idx) => {
                        const label = String.fromCharCode(65 + idx);
                        const isChecked = answer.answerKey === child.userAnswerKey ? 'checked' : '';
                        const isSelected = answer.answerKey === child.userAnswerKey ? 'selected' : '';
                        html += `
                            <div class="answer-option ${isSelected}" onclick="selectAnswer('${child.questionKey}', '${answer.answerKey}')">
                                <input type="radio" name="answer_${child.questionKey}" id="answer_${answer.answerKey}"
                                       value="${answer.answerKey}" ${isChecked}>
                                <label for="answer_${answer.answerKey}">
                                    <span class="label-text">${label}</span>
                                    <span class="colon">:</span>
                                    <span class="answer-content">${answer.answerText}</span>
                                </label>
                            </div>
                        `;
                    });
                    html += '</div></div>';
                });
                html += '</div></div>';
            });
            container.innerHTML = html;

            document.querySelectorAll('.question-container, .sub-question').forEach(element => {
                const questionKey = element.getAttribute('data-question-key');
                if (questionKey) {
                    const answerOptions = element.querySelector('.answer-options');
                    if (answerOptions) {
                        answerOptions.addEventListener('mouseover', () => {
                            if (questionStates[questionKey]) {
                                questionStates[questionKey].hasInteracted = true;
                                checkStartTime(questionKey);
                            }
                        });
                    }
                }
            });

            document.querySelectorAll('.flag-icon').forEach(flag => {
                flag.addEventListener('click', () => {
                    const questionKey = flag.getAttribute('data-question-key');
                    toggleFlag(questionKey);
                });
            });

            setupIntersectionObserver();
        }
                function scrollToQuestion(questionKey) {
            const element = document.getElementById(`question-${questionKey}`);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
              function showConfirmationModal(title, message, onConfirm) {
            const modal = document.getElementById('confirmation-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalMessage = document.getElementById('modal-message');
            const confirmBtn = document.getElementById('modal-confirm');
            const cancelBtn = document.getElementById('modal-cancel');

            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modal.classList.add('active');

            confirmBtn.onclick = () => {
                modal.classList.remove('active');
                if (onConfirm) onConfirm();
            };

            cancelBtn.onclick = () => {
                modal.classList.remove('active');
            };
        }
             function updateAnswer(questionKey, answerKey) {
            let question = questions.find(q => q.questionKey === questionKey);
            if (!question) {
                for (const parent of questions) {
                    if (parent.children) {
                        question = parent.children.find(child => child.questionKey === questionKey);
                        if (question) break;
                    }
                }
            }

            if (question) {
                question.userAnswerKey = answerKey; // Có thể là null khi bỏ chọn
                const answerOptions = document.querySelectorAll(`.answer-option input[name="answer_${questionKey}"]`);
                answerOptions.forEach(option => {
                    const parent = option.parentElement;
                    if (answerKey === null) {
                        option.checked = false;
                        parent.classList.remove('selected');
                    } else if (option.value === answerKey) {
                        parent.classList.add('selected');
                    } else {
                        parent.classList.remove('selected');
                    }
                });
                updateQuestionList();
            } else {
                console.error(`Question with key ${questionKey} not found.`);
            }
        }
               function toggleSidebar() {
            const leftSidebar = document.querySelector('.sidebar-left');
            const rightSidebar = document.querySelector('.sidebar-right');

            // Hành vi trên màn hình nhỏ (dưới 768px)
            if (window.innerWidth <= 768) {
                sidebarState = (sidebarState + 1) % 3; // Chuyển trạng thái: 0 -> 1 -> 2 -> 0

                if (sidebarState === 1) {
                    // Trạng thái 1: Hiển thị sidebar-left, ẩn sidebar-right
                    leftSidebar.classList.add('active');
                    rightSidebar.classList.remove('active');
                } else if (sidebarState === 2) {
                    // Trạng thái 2: Ẩn sidebar-left, hiển thị sidebar-right
                    leftSidebar.classList.remove('active');
                    rightSidebar.classList.add('active');
                } else {
                    // Trạng thái 0: Ẩn cả hai
                    leftSidebar.classList.remove('active');
                    rightSidebar.classList.remove('active');
                }
            } else {
                // Hành vi trên màn hình lớn (trên 768px): Giữ nguyên như cũ
                leftSidebar.classList.toggle('active');
                rightSidebar.classList.toggle('active');
            }
        }
        function startTimer() {
            const timerElement = document.getElementById('timer');
            setInterval(() => {
                if (timeRemaining > 0) {
                    timeRemaining--;
                    let minutes = Math.floor(timeRemaining / 60);
                    let seconds = Math.floor(timeRemaining % 60);
                    timerElement.textContent = `Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    if (timeRemaining <= 300) {
                        timerElement.classList.add('warning');
                    }
                } else {
                    timerElement.textContent = 'Time: 00:00';
                    submitStudy();
                }
            }, 1000);
        }

             window.onload = async function () {
                 window.addEventListener('beforeunload', handleBeforeUnload);
                await loadFlaggedQuestions();
            startTimer();
            renderContent();
            updateQuestionList();

            questions.forEach(q => {
                initializeQuestionState(q.questionKey, q.part);
                if (q.children) {
                    q.children.forEach(child => initializeQuestionState(child.questionKey, child.part));
                }
            });

            document.getElementById('question-list').addEventListener('click', function(event) {
                if (event.target.classList.contains('question-circle')) {
                    event.preventDefault();
                    const questionKey = event.target.getAttribute('data-key');
                    if (questionKey) {
                        scrollToQuestion(questionKey);
                    }
                }
            });
        };
          document.addEventListener('keydown', (event) => {
            // Xử lý phím số để chuyển Part (giữ nguyên)
          

            // Logic điều hướng bằng mũi tên - Phiên bản cuối cùng, đáng tin cậy
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                event.preventDefault();

                // 1. Lấy TẤT CẢ các câu hỏi đang hiển thị trong nội dung chính. Đây là "nguồn sự thật".
                const questionsOnPage = Array.from(document.querySelectorAll('.question-container, .sub-question'));
                if (questionsOnPage.length < 2) return; // Không cần điều hướng nếu có ít hơn 2 câu

                // 2. Xác định câu hỏi hiện tại (vẫn dùng phương pháp tâm màn hình)
                const viewportCenter = window.innerHeight / 2;
                let currentQuestionOnPage = null;
                let minDistanceToCenter = Infinity;

                questionsOnPage.forEach(q => {
                    const rect = q.getBoundingClientRect();
                    const questionCenter = rect.top + (rect.height / 2);
                    const distance = Math.abs(questionCenter - viewportCenter);

                    if (distance < minDistanceToCenter) {
                        minDistanceToCenter = distance;
                        currentQuestionOnPage = q;
                    }
                });

                if (!currentQuestionOnPage) return;

                // 3. Tìm VỊ TRÍ (index) của câu hỏi hiện tại TRONG danh sách câu hỏi nội dung chính.
                const currentIndex = questionsOnPage.indexOf(currentQuestionOnPage);
                if (currentIndex === -1) return;

                // 4. Xác định câu hỏi tiếp theo BẰNG CÁCH lấy phần tử trước/sau trong chính danh sách đó.
                let nextIndex = currentIndex;
                if (event.key === 'ArrowUp' && currentIndex > 0) {
                    nextIndex--;
                } else if (event.key === 'ArrowDown' && currentIndex < questionsOnPage.length - 1) {
                    nextIndex++;
                }

                // 5. Cuộn đến câu hỏi tiếp theo.
                const nextQuestionOnPage = questionsOnPage[nextIndex];
                if (nextQuestionOnPage && nextQuestionOnPage !== currentQuestionOnPage) {
                    nextQuestionOnPage.scrollIntoView({ behavior: 'smooth', block: 'center' });

                    // 6. (Phụ) Cập nhật vòng tròn active ở sidebar cho đẹp.
                    const nextKey = nextQuestionOnPage.getAttribute('data-question-key');
                    if (nextKey) {
                        const questionCircles = Array.from(document.querySelectorAll('.question-circle'));
                        questionCircles.forEach(circle => {
                            if (circle.getAttribute('data-key') === nextKey) {
                                circle.classList.add('active');
                            } else {
                                circle.classList.remove('active');
                            }
                        });
                    }
                }
            }
        });
                function getTotalQuestions() {
            let total = 0;
            questions.forEach(q => {
                if (q.parent === null) {
                    if (q.children && q.children.length > 0) {
                        total += q.children.length;
                    } else {
                        total += 1;
                    }
                }
            });
            return total;
        }

        function getAnsweredQuestions() {
            let answered = 0;
            questions.forEach(q => {
                if (q.parent === null && q.children && q.children.length > 0) {
                    answered += q.children.filter(child => child.userAnswerKey && child.userAnswerKey !== '').length;
                } else if (q.parent === null && q.userAnswerKey && q.userAnswerKey !== '') {
                    answered += 1;
                }
            });
            return answered;
        }

        function updateProgressCircle() {
            const totalQuestions = getTotalQuestions();
            const answeredQuestions = getAnsweredQuestions();
            const text = document.getElementById('progress-text');
            text.textContent = `${answeredQuestions}/${totalQuestions}`;
        }

        window.onpageshow = function (event) {
            if (event.persisted) {
                // Trang được tải từ cache, buộc làm mới để gọi OnGetAsync
                window.location.reload();
            }
        };
        // ... Dán các hàm JS còn lại vào đây ...
    </script>
</body>
</html>